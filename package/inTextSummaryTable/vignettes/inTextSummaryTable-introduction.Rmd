---
title: "Introduction to the `inTextSummaryTable` package"
author: "Laure Cougnaud"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: glpgStyle::html_report
vignette: >
  %\VignetteIndexEntry{Introduction to the inTextSummaryTable package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

```{r options, echo = FALSE}
	
	library(knitr)
	opts_chunk$set(
		echo = TRUE, results = 'markup', warning = FALSE, 
		# stop document execution if error (not the default)
		error = FALSE, 
		message = FALSE, cache = FALSE,
		fig.width = 8, fig.height = 7,
		fig.path = "./figures_vignette/",
		fig.align = 'center')
	options(width = 170)
	# instead of warn = 0 by default
	# include warnings when they occur in the document
	options(warn = 1)
	
```

The package `inTextSummaryTable` contains functionalities to **create
complex table of summary statistics or counts of metrics of interest**, to
**format them as in-text table for the Clinical Study Report**.

These tables can be included into a `rmarkdown` document, to be
converted into `html`, `docx` and `pptx`.
Each table can be exported into a `docx` document.

```{r loadPackages}

	library(inTextSummaryTable)
	library(pander)

```

## Data format

The input data for the creation of summary table should be a **data.frame**,
usually loaded from _SAS_ data file (`sas7bdat` format).
The label of the variables stored in the `SAS` datasets is also used
for the title/captions. 

Example datasets from the _Pelican_ study included in the
`glpgpUtilityFct` package are used for demonstration in the
vignette.  

Note that the `loadDataADaMSDTM` function of the `glpgUtilityFct` package can
be used to your custom `SAS` dataset(s) of interest.

```{r loadData}	
	
	library(glpgUtilityFct)
	library(tools)# toTitleCase

	# load example data
	data(ADaMDataPelican)
	data(labelVarsADaMPelican)
	
	dataAll <- ADaMDataPelican
	labelVars <- labelVarsADaMPelican

```

# Summary table

The main workhorse function is: **`getSummaryStatisticsTable`** which creates an
in-text table of summary statistics for variable(s) of interest.

## General type: summary statistics and/count table

Two types of table can be created: a count or summary table.

By default, the type of the table is **automatically detected** based on the
variable type. This can also be specified via the `type` parameter set to:
`summaryTable`, `countTable` or `auto` (by default, mixed type).

Note: all functionalities described below for the summary statistics table are
also available for the count table (and vice versa).

The _Demographic_ data (`ADPD` dataset) is used as example for the summary
statistics table.

```{r data-SL}

	dataSL <- dataAll$ADSL

```

### Count table

A **count table for discrete variable** (integer, factor, character) indicates
the counts of the number of subjects or records per category of interest (if
\code{var} is specified)

#### Simple count table

If **no variable is specified** (`var` parameter), the number of
subjects (`statN`)/records (`statm`) and percentage of subjects (`statPercN`)
are counted in the **entire dataset**.

(The `statPercTotalN` contains the denominator 'total' used for the
percentage computation.)

```{r count-simple}

	getSummaryStatisticsTable(data = dataSL)

```

#### Count table of categories

If a **variable is specified** via the `var` parameter, the **counts of each
sub-category/class** of the specified variable are extracted.

```{r count-categories}

	getSummaryStatisticsTable(data = dataSL, var = "SEX")

```

To include categories which are not present in the data:

* all categories to include should be specified within the levels of the `var`
factor variable
* the `varInclude0` should be set to `TRUE`

```{r count-categories-empty}

	dataSLExample <- dataSL
	
	# 'SEX' formatted as character with only male
	dataSLExample$SEX <- "M" # only male
	getSummaryStatisticsTable(data = dataSLExample, var = "SEX")
	
	# 'SEX' formatted as factor, to include also female in the table
	# (even if not available in the data)
	dataSLExample$SEX <- factor("M", levels = c("F", "M"))
	getSummaryStatisticsTable(data = dataSLExample, var = "SEX", varInclude0 = TRUE)

```

#### Count table for 'flag'-variables

For **'flag' variable** (typically ending with 'FL' in _ADaM_ or _SDTM_ format),
only the counts for the flagged records are typically of interest.
If some of the variables are of this type, they should be passed additionally to the 
`varFlag` parameter.

```{r count-flag-variables}

	varFlag <- grep("FL$", colnames(dataSLExample), value = TRUE)
	getSummaryStatisticsTable(
		data = dataSLExample,
		var = varFlag,
		varFlag = varFlag
	)

```

### Summary statistics table

**A summary statistics table** indicates **standard distribution statistics** of a numeric variable:
  (mean, median, minimum, maximum, standard error, standard deviation, and count
  statistics)

If `var` parameter is set to a numeric variable of interest, its summary
statistics are displayed.

```{r numeric}

	getSummaryStatisticsTable(data = dataSL, var = "AGE")

```

### Mixed table

Summary statistics are extracted for a combined set of discrete and numeric variables.

```{r mixedTable}

	getSummaryStatisticsTable(
		data = dataSL, 
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL", "RACE", "SEX")
	)

```

## Format statistics

The set of summary statistics can be combined and the format customized via the `stats` 
parameter. 
This parameter is an list of `expression` of the statistics (columns) computed by default (`stat[X]` variable(s)).

If an unique statistic expression is specified, the 'Statistic' column doesn't appear 
in the table. In case multiple statistics are specified, these are included as separated row.

### User-custom set of statistics

For example, the following count table is restricted to the number of subjects
per categories:

```{r stats-N}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("RACE", "SEX"),
		stats = list(N = expression(statN))
	)

```

The summary statistics table is restricted to the median and
range:

```{r stats-meanSE}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL"),
		varGeneralLab = "Parameter", statsGeneralLab = "",
		colVar = "ACTARM",
		stats = list(
			`median` = expression(statMedian),
			`(min, max)` = expression(paste0("(", statMin, ",", statMax, ")"))
		)
	)

```

### Default sets of available statistics

A common default set of statistics are available via the `getStats` function
which can be passed directly to the `stats` function.

For a continuous variable, it is **recommended to pass also the
variable to the `getStats` function** to get
standard number of number of decimals 
(see section \@ref(numberDecimalsContinuousVariable)).

```{r getStats}

	## count table:

	# count: N, '%' and m
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = getStats("count")
	)

	# n (%)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = getStats("n (%)")
	)
	
	## continuous variable
	
	# all summary stats
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("summary")
	)
	
	# median (range)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("median (range)")
	)
	
	# median and (range) in a different line:
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("median\n(range)")
	)
	
	# mean (se)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("mean (se)")
	)

```

### By variable/group

The statistics can also be provided for each variable separately:

```{r statExtra-EachVariable}
		
	getSummaryStatisticsTable(
		data = dataSL, 
		var = c("AGE", "RACE"),
		stats = list(
			AGE = getStats("median (range)"),
			RACE = getStats("n (%)")
		)
	)

```

### Extra statistics

Extra statistics (not available in the default set of statistics) should 
be specified via the `statsExtra` parameter.

These statistics are then available for customization via the `stats` parameter.

For example, the Coefficient of Variation (as a percentage) is computed for the
height.

```{r statsExtra}

	# include the coefficient of variation via the 'statsExtra' parameter
	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		statsExtra = list(statCVPerc = function(x) sd(x)/mean(x)*100)
	)
	
	# format the statistics with the 'stats' parameter
	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		statsExtra = list(statCVPerc = function(x) sd(x)/mean(x)*100),
		stats = list(Mean = expression(statMean), 'CV%' = expression(statCVPerc))
	)

```

### Number of decimals

To specify fixed amounts of digits for the statistics to be displayed in the table, 
the statistics are formatted in the `stats` parameter.

Some internal defaults (based on Mock TLFs) are available for a counts or summary table when the
set of statistics of interest are extracted with the `getStats` function.

#### `getStats` function

##### Categorical variable

When the `getStats` function is used,
the counts for a categorical variables are formatted as described in the Mock TLFs:

* the number of subjects is displayed with 0 digits (`nDecN` is set to 0)
* the percentage is subjects is displayed as implemented in the `formatPercentage` function

```{r getStats-count}

	# Internal rule for the number of decimals for the percentage
	formatPercentage(c(NA, 0, 100, 99.95, 0.012, 34.768))
	
	# Used by default in the 'getStats' function
	getStats(type = "count")

```

##### Continuous variable {#numberDecimalsContinuousVariable}

When specifying the default set of available statistics with the `getStats` function,
and **only if the variable is specified** (`x` parameter),
the number of decimals for a continuous variable is determined by:

1. Extracting the number of decimals for individual values based on:
    + **pre-defined rules** via the `getNDecimalsRule` function, as defined in the Mock TLF
    + the number of decimals **available in the input data** via the `getNDecimalsData` function
    + taking the **minimum of these two criterias** (`getNDecimals` function), 
    such as the number of decimals according
    the rule won't be higher that the actual number of decimals available in the data
2. Taking the **maximum number of decimals** across all individual values via the `getMaxNDecimals` function, 
which is used as 'base' number of decimals considered for the summary statistics
3. The actual number of decimals for each statistic is extracted (based on the Mock TLFs) by adding
to the 'base' number of decimals:
    + **0 extra decimal for the minimum, maximum**
    + **1 extra decimal for the mean, median, sd**
    + **2 extra decimals for SE**

Please note that if a different framework than implemented in steps 1 and 2
should be used for the extraction of the number of decimals for a specific variable,
the number of decimals of interest can be fixed via the `nDecCont` parameter.

```{r getMaxNDecimals}

	# %FEV1 at baseline
	print(dataSL$PFEVBL)
	
	## Extract the number of decimals for each value:
	
	# based on pre-defined rule, this metric should be displayed with 1 decimal:
	getNDecimalsRule(x = dataSL$PFEVBL)
	
	# but available in the data only with 0 decimals
	getNDecimalsData(x = dataSL$PFEVBL)
	
	# The minimum of the #decimals based on the data and pre-defined rule is:
	getNDecimals(x = dataSL$PFEVBL)
	
	## Take the maximum number of decimals 
	getMaxNDecimals(x = dataSL$PFEVBL)
	
	## Custom set of statistics are extracted when x is specified:
	getStats(x = dataSL$PFEVBL)
	
	# To fix the number of decimals:
	getStats(type = "summary", nDecCont = 1)
	
	## Create summary statistics table
	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "PFEVBL"),
		stats = list(
			AGE = getStats(type = "median (range)", x = dataSL$AGE),
			PFEVBL = getStats(type = "median (range)", x = dataSL$PFEVBL)
		)
	)

```

Notes: by default the `round` function in R rounds the number to the even number in case of 0.5. 
The `roundCustomText` function rounds to the closest digit.

#### Custom `stats` function (Advanced)

A  custom function can be created to create custom statistics with fixed number of digits.

For example, the AGE is displayed with 1 digit and the height with two digits:

```{r stats-digits}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(
			AGE = list(Median = expression(roundCustomText(statMedian, 1))),
			HEIGHT = list(Median = expression(roundCustomText(statMedian, 2)))
		)
	)

```

To create the `stats` parameter for a specific number of digits,
a custom function can be created:

```{r stats-digits-complex}

	# wrapper function to include median with specific number of digits
	# and min/max with specified number of digits - 1
	statsDMNum <- function(digitsMin)
		list('Median (range)' = 
			bquote(paste0(
				roundCustomText(statMedian, .(digitsMin+1)), 
				" (", roundCustomText(statMin, .(digitsMin)), ",", 
				roundCustomText(statMax, .(digitsMin)),
				")"
			))
	)

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL", "RACE", "SEX"),
		stats = list(
			AGE = statsDMNum(0),
			HEIGHT = statsDMNum(1),
			WEIGHTBL = statsDMNum(1),
			BMIBL = statsDMNum(1),
			RACE = getStats("n (%)"),
			SEX = getStats("n (%)")
		)
	)

```

### Statistics layout

The layout of the statistics is specified via the `statsLayout` parameter.  

By
default, the statistics are included in rows, after each element of the row
variable(s).

```{r statsLayoutRow}

	# statsLayout = 'row'
	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE))
	)
	
```

The statistics can also be included in columns.

```{r statsLayoutCol}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE)),
		statsLayout = "col"
	)

```

The statistics can also be specified in different rows, but in a separated column.

```{r summaryTable-PP-medianMinMax-statsLayoutRowVarInSepCol}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE)),
		statsLayout = "rowInSepCol"
	)

```

## Table layout

Grouping variable can be specified in the vertical direction (across rows) or
in the horizontal direction (across columns).

The adverse events dataset is used for demonstration.

```{r countTable-AE-data}
				
	dataAE <-  subset(dataAll$ADAE, FASFL == "Y" & TRTEMFL == "Y")
	dataAEInterest <- subset(dataAE, AESOC %in% c("Infections and infestations", "General disorders and administration site conditions", "Ear and labyrinth disorders"))

	# ensure that order of elements is the one specified in the corresponding numeric variable
	library(glpgUtilityFct)
	dataAEInterest <- convertVarToFactor(
		data = dataAEInterest, 
		var = c("TRTP", "AESEV"),
		varNum = c("TRTPN", "AESEVN")
	)

```

### Row and column variables

Specific grouping variable(s) for the columns can be specified via the
**`colVar`** parameter and for the rows via the **`rowVar`** parameter.

If multiple category variables are specified, they should be specified in
hierarchical order.

```{r rowVarColVar}

	# unique row variable
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = "AEDECOD",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# multiple nested row variables
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# unique column variable
	getSummaryStatisticsTable(
		data = dataAEInterest,
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# combination of rows and columns
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars,
		colHeaderTotalInclude = FALSE
	)

```

### Include empty row/columns

The parameters **`rowInclude0` and `colInclude0`** are set to TRUE to 
**include statistics for empty categories** within the row/column. 

These categories are specified via additional **levels in the `rowVar`/`colVar` factor variables**.

```{r countTable-emptyVars}

	## only consider White blood cell adverse events
	dataAESubset <- subset(dataAE, AEHLT == "Viral infections NEC")
	
	## create dummy categories for:
	# treatment
	dataAESubset$TRTP <- with(dataAESubset, 
		factor(TRTP, levels = c(unique(as.character(TRTP)), "Treatment B"))
	)
	# low-level term category
	dataAESubset$AELLT <- with(dataAESubset, 
		factor(AELLT, levels = c(unique(as.character(AELLT)), "Lymphocyte percentage increased"))
	)
	
	# create summary statistics table
	getSummaryStatisticsTable(
		data = dataAESubset,
		type = "count",
		rowVar = c("AEHLT", "AELLT"),
		rowInclude0 = TRUE, colInclude0 = TRUE,
		colVar = "TRTP",
		labelVars = labelVars,
		title = "Table: Adverse Events: white blood cell analyses",
		stats = getStats("n (%)"),
		footer = "Statistics: n (%)"
	)

```

### Row variable

By default, if multiple row variables are specified, they are considered nested
and displayed in the first column of the final table.
Each sub-category is indicated with a specific indent (customizable with
`rowVarPadBase`).

#### Variable in separated column

**Row variables** that shouldn't be included in the unique column with the row
variables, but as **separated column** are additionally specified via the
`rowVarInSepCol` parameter.

```{r rowVarInSepCol}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD", "AESEV"),
		rowVarInSepCol = "AESEV",
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
```

#### Row ordering

The **categories in the row variables can be ordered** based on the
**`rowOrder`** variable. 

This variable is either:

* a string with the name of an implemented method to order the rows, among:
     + `alphabetical`: categories are ordered **alphabetically**
     + `auto`: categories are ordered based on the **levels** if the input variable is a factor, 
     alphabetically otherwise
     + `total`: categories are ordered based on the 'total' column (see \@ref(colTotal)) 
     (computed even if not included in the table)
* a custom ordering function to apply in the data to order the rows

##### Common order for all row variables

```{r rowOrder-common}

	# 'auto'
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# total counts
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE, colTotalLab = "Number of subjects",
		rowOrder = "total",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	# same order even if the 'total' column is not specified
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", 
		rowOrder = "total", 
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

##### Different orders for each row variable

In case the order should be different for each row variable, a named list is
provided for the `rowVar` parameter.

```{r rowOrder-specific}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", #colTotalInclude = TRUE,
		rowOrder = c(AESOC = "alphabetical", AEDECOD = "total"),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

##### Row order based on the total of a column category

If the row categories should be **ordered by total counts for a specific
category of the column variable(s)**, a function **`rowOrderTotalFilterFct`** is
specified.

The adverse events are sorted based on the incidence in the treated group.

```{r rowOrder-filterFct}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		rowOrder = "total",
		stats = getStats("n (%)"),
		labelVars = labelVars,
		# consider only the counts of the treated patients to order the rows
		rowOrderTotalFilterFct = function(x) subset(x, TRTP == "treatmentX")
	)

```

##### Row order based on a custom specified function

If the method to order the rows is more complex, the `rowOrder` parameter specifies
a function taking the summary table as input and returning the order
levels of the elements in the row variable.

For example, the adverse event table is sorted based on the counts of patient
presenting this event across all treatment classes, and in case of ties based on 
the counts of treated-patients presenting this event.

```{r countTable-LB-rowOrder-customFunction}

	library(plyr)
	getSummaryStatisticsTable(
		data = dataAEInterest,
		type = "count",
		rowVar = "AEHLT",
		rowOrder = function(x){
			x <- subset(x, !isTotal)
			totalAcrossTreatments <- subset(x, TRTP == "Total")
			# counts across treated patients
			totalForTreatmentOnly <- subset(x, TRTP == "treatmentX")
			dataCounts <- merge(totalAcrossTreatments, totalForTreatmentOnly, by = "AEHLT", suffixes = c(".all", ".treat"))
			# sort first based on overall count, then counts of treated patients
			dataCounts[with(dataCounts, order(`statN.all`, `statN.treat`, decreasing = TRUE)), "AEHLT"]
		},
		colVar = "TRTP", colTotalInclude = TRUE,
		labelVars = labelVars,
		title = "Table: Adverse Events ordered based on total counts",
		stats = list(expression(paste0(statN, " (", round(statPercN, 1), ")"))),
		footer = "Statistics: n (%)"
	)

```

#### Row variable labels

##### Based on dataset

The **labels used for the variables parameter** (row variables) **are
automatically extracted from the labels** contained in the _SAS_ dataset, by
specifying the `labelVars` parameter.

```{r summaryTable-PP-rowVarWithLabel-labelVars}

	# combination of rows and columns
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
```

##### Custom

The label can also be specified directly via the `rowVarLab` parameter,
for each variable in `rowVar`.

If an unique row label should be used (even if multiple row variables are
specified), `rowVarLab` is set to this unique label.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		labelVars = labelVars
	)
	
```

## Total

The **total number of subjects** is displayed in the **column header**
and used for the **computation of the percentages** in the table body.

### External dataset

By default, this total is extracted from the **available number of subjects** 
in the input `data`.

 If the total should be extracted
from a **different dataset**, e.g. if only a subset of the patients are present
in the data, it should be specified via the **`dataTotal`** variable (by default set to `data`).

For example, the total number of patients per treatment arm is extracted from the 
subject-level (`ADSL`) dataset. 

```{r countTable-LB-customDenominator}

	# dataset used to extract the 'Total'
	dataTotalAE <- subset(dataAll$ADSL, TRT01A != "Screen Failure")
	# should contain columns specified in 'colVar'
	dataTotalAE$TRTA <- dataTotalAE$TRT01A 
	
	# by default, total number of subjects extracted from data
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		labelVars = labelVars
	)
	# and on dataTotal if specified:
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

### Computation of the percentage

A different dataset used for the computation of the percentage can be specified
via the `dataTotalPerc` (by default set as `dataTotal`).
If the total number of subjects differ between the components of the table, 
the extra row/column(s) variable(s) are specified via `colVarTotalPerc`/`rowVarTotalPerc`.

For example, in the table of shift of worst-case laboratory abnormalities: the total number
of subjects for the computation of the percentage are extracted based on the number of subjects 
with available post-dose measurements **per laboratory parameter**.

```{r rowVarTotalPerc}

	dataLB <- subset(dataAll$ADLB, FASFL == "Y" & PARAMCD %in% c("BACT", "ALB"))
	
	# worst-case scenario with abnormalities
	dataLBWC <- subset(dataLB, AVISIT == "Worst-case post-baseline" & SHIFT1 != "")

	# data considered for the total
	dataLBPostBaseline <- subset(dataLB, !AVISIT %in% c("Baseline", "Screening", "Worst-case post-baseline"))
	
	# post-baseline measurements  are not available for all subjects 
	kable(aggregate(USUBJID ~ PARAM + TRTA, data = dataLBPostBaseline, function(x) length(unique(x))))
	
	# by default, the same total number of subjects 
	# per treatment is used across all rows/parameters
	getSummaryStatisticsTable(
		data = dataLBWC,
		colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
		stats = getStats("n (%)"),
		emptyValue = 0, rowAutoMerge = FALSE,
		dataTotal = dataLBPostBaseline
	)
	
	# percentage based on total number of subjects with available
	# post-baseline measurements PER parameter:
	getSummaryStatisticsTable(
		data = dataLBWC,
		colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
		stats = getStats("n (%)"),
		emptyValue = 0, rowAutoMerge = FALSE,
		# total for column header
		dataTotal = dataLBPostBaseline, 
		dataTotalPerc = dataLBPostBaseline,
		rowVarTotalPerc = "PARAM"
	)
	
```

### Total number of subjects across columns {#colTotal}

The total of the number of subjects **across all columns** is included 
if the `colTotalInclude` is set to TRUE.

By default, the total number of subjects is extracted based on the
input dataset across columns: subjects presenting the **same event in multiple column(s) are counted once**
in the column total (e.g. for adverse event table in a context of cross-over experiment).
A different dataset for the total column can also be specified via the `dataTotalCol` parameter.

This column is by default labelled 'Total', but this can be customized with the
`colTotalLab` parameter.

```{r colTotal}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		colTotalInclude = TRUE, colTotalLab = "All subjects",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

### Row total

If the total should be included across elements of specific `rowVar`
variable(s), this(these) variable(s) should be included in `rowVarTotalInclude`.

For the first row variable, the total is included in the first row of the table,
with the label specified in `rowTotalLab`.

```{r rowVarTotalInclude1}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AESOC", rowTotalLab = "Any AE", 
		rowVarTotalInSepRow = "Any AE",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

In case multiple row variables are specified, the total can also
be included for each of this variable.
In this case, the total is by default included in the header of each category
of this variable.

```{r rowVarTotalInclude2}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD", 
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

This total can also be included as a separated category in the table, if this
variable is additionally specified in `rowVarTotalInSepRow`.

```{r rowVarTotalInclude-rowVarTotalInSepRow}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD",
		rowVarTotalInSepRow = "AEDECOD",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

A different dataset considered for the row total is specified via the 
`dataTotalRow` parameter.

For example, in the worst-case treatment-emergent adverse events table, the total
per SOC and across SOCs should count the patient once per severity class.

For example, the patient: '202-4903-03' present a moderate severity for headache, and mild severity
for the chest injury and fall, but is only counted in the once in the table total.

```{r dataTotalRow}

	dataTEAEInterest <- subset(
		dataAll$ADAE, 
		SAFFL == "Y" & TRTEMFL == "Y" &
		AESOC %in% c("Injury, poisoning and procedural complications", "Nervous system disorders")
	)

	# extract worst-case scenario data (only one record if multiple with same severity)
	dataTEAEInterestWC <- ddply(dataTEAEInterest, c("AEDECOD", "USUBJID", "TRTA"), function(x){
		x[which.max(x$AESEVN), ]
	})
	kable(ddply(dataTEAEInterestWC[, c("USUBJID", "TRTA", "AESOC", "AEDECOD", "AESEV", "AESEVN")], "USUBJID"), split.tables = Inf)

	## datasets used for the total: 
	# for total: compute worst-case across SOC and across AE term
	# (otherwise patient counted in multiple categories if present different categories for different AEs)
	dataTotalRow <- list(
		# within SOC (across AEDECOD)
		'AEDECOD' = ddply(dataTEAEInterestWC, c("AESOC", "USUBJID", "TRTA"), function(x){	
			x[which.max(x$AESEVN), ]
		}),
		# across SOC
		'AESOC' = ddply(dataTEAEInterestWC, c("USUBJID", "TRTA"), function(x){	
			x[which.max(x$AESEVN), ]
		})
	)

	getSummaryStatisticsTable(
		data = dataTEAEInterestWC,
		## row variables:
		rowVar = c("AESOC", "AEDECOD", "AESEV"), rowVarInSepCol = "AESEV",
		# include total across SOC and across AEDECOD
		dataTotal = dataTotalAE, # total for column header and denominator
		rowVarTotalInclude = c("AESOC", "AEDECOD"), 
		dataTotalRow = dataTotalRow, # data for total row
		rowVarTotalByVar = "AESEV", # count for each severity category for the total
		rowTotalLab = "Any TEAE", 
		rowVarLab = c(AESOC = "Subjects with, n(%):", AESEV = "Worst-case scenario"),
		# sort per total in the total column
		rowOrder = "total", 
		## column variables
		colVar = "TRTA", 
		stats = getStats("n (%)"),
		emptyValue = "0",
		labelVars = labelVars
	)

```

### Remove total in column header

The total number of subjects in each column is by default included.
This is not displayed if `colHeaderTotalInclude` is set to FALSE.

```{r colHeaderTotalInclude}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD",
		rowVarTotalInSepRow = "AEDECOD",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		colHeaderTotalInclude = FALSE
	)

```

## Labels

If the data is loaded into R with the `read_haven` of the `haven` package,
 or the `loadDataADaMSDTM` function of the `glpgUtilityFct` package, the label
 for each variable is stored in the 'label' attribute of the corresponding
 column.

However, if this label is lost (e.g. if the object is subsetted), 
labels are specified via the `labelVars` parameter for all variables at once, 
or via specific `[parameter]Lab` parameter, as `rowVarLab`/`colVarLab`/`varLab`
for the row/column/variable to summarize respectively.

## Title and footnote

Title and footnote are specified via the corresponding `title` and `footer` parameters.
The convenient function `toTitleCase` from the `tools` package
is used to set title case for the title of the summary statistics table.

```{r titleAndFooter}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = toTitleCase("MOR106-CL-102: Adverse Events by System Organ Class and Preferred Term (Safety Analysis Set, Part 1)"),
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		)
	)

```

## Text customization

The pharmacokinetics data is used for demonstration.

```{r data-ADSL}
	
	dataPP <- subset(dataAll$ADPP, SAFFL == "Y")
	
	# ensure that order of elements is the one specified in the corresponding numeric variable
	library(glpgUtilityFct)
	dataPP <- convertVarToFactor(
		data = dataPP, 
		var = c("PARCAT1", "PARAM", "AVISIT", "TRTP"), 
		varNum = c("PARCAT1N", "PARAMN", "AVISITN", "TRTPN")
	)
	
```	

### Superscript/subscript

Superscript and superscript are specified via the special text pattern: `a^{b}`
and subscript as `a_{b}` respectively.

To use a superscript or a subscript in
the table, the text should be formatted as:
`text^{superscript}` or `text_{subscript}`.

This is for example useful to reference additional informations in a specific
footnote or specify custom variable labels.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab-superscript}

	# format labels with subscript
	paramLabelPK <- c(
		CTROUGH = "C_{trough} (ng/mL)", 
		TLAG = "t_{lag} (h)",
		TMAX = 't_{max} (h)', 
		CMAX = "C_{max} (ng/mL)",
		AUCTAU = "AUC_{0-t} (ng.h/mL)",
		AUC08H = "AUC_{0-8h} (ng.h/mL)"
	)
	dataPP$PARAMRF <- paramLabelPK[dataPP$PARAMCD]
	
	getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 %in% c("Ivacaftor", "Lumacaftor")),
		var = "AVAL",
		colVar = "TRTP",
		rowVar = c("PARCAT1", "PARAMRF"),
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter\nfor each compound^{(1)}", # use superscript for the foonote
			'PARCAT1' = "" 
		),
		stats = list(expression(paste0(roundCustomText(statMean, 1), "\n(", roundCustomText(statSE, 2),")"))),
		# include the footnote
		footer = "(1) Each compound is labelled according to its Galapagos compound ID."
	)	

```

## Multiple table creation

Multiple tables can be created for each element of
a variable in the dataset by specifying this variable in `byVar`.

For example, pharmacokinetic tables are created for each compound:

```{r byVar}

	summaryTableList <- getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 %in% c("Ivacaftor", "Lumacaftor")),
		var = "AVAL",
		colVar = "TRTP",
		rowVar = "PARAMRF",
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter", 
			'PARCAT1' = "Compound^{(1)}" # use superscript for the foonote
		),
		byVar = "PARCAT1", 
		labelVars = labelVars,
		stats = list(expression(paste0(roundCustomText(statMean, 1), "\n(", roundCustomText(statSE, 2),")")))
	)	
	# print the list of tables in the rmarkdown document
	glpgUtilityFct::knitPrintListObjects(summaryTableList) 

```

A list of `flextable` can be included into a `rmarkdown` document with the
`knitPrintListObjects` (see [section](#outputFormat)).

## Filter records in a table

If only a subset of the records should be displayed in the final table,
a custom filtering functions is specified via the `filterFct` parameter.

```{r countTable-AE-filterFct}

	library(plyr)
		
	# SOC with AE terms with at least 2 subjects
	getSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		filterFct = function(x)
			ddply(x, "AESOC", function(y)
				if(any(y$statN >= 2))	y			
			),
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term with at least 2 patients in System Organ Class"
	)
	
	# AE term with at least one term with more than 20% in the treatment
	getSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		filterFct = function(x)
			ddply(x, "AEDECOD", function(xTerm){
				xTermTreatment <- subset(xTerm, grepl("75 mg", TRTP))
				if(xTermTreatment$statPercN >= 20)	xTerm		
			}),
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term with at least 20% patients in treatment category"
	)
	
```

Note: to help for the creation of this filtering function,
the displaying data could be extracted first via the `computeSummaryStatisticsTable`
function (instead of creating directly the in-text table via the
`getSummaryStatisticsTable`), then used to define the `filterFct` parameter.

```{r countTable-AE-filterFct- details}

	x <- computeSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	head(x)
	# for specific AEDECOD
	xTerm <- subset(x, AEDECOD == "Viral upper respiratory tract infection")
	# identify the record for treated patient:
	subset(xTerm, grepl("75 mg", TRTP))
	# keep all records (placebo + treatment) if percentage if higher than 20%:
	# if no 'else' condition, nothing (NULL) is returned:
	if(subset(xTerm, grepl("75 mg", TRTP))$statPercN >= 20)	xTerm
	# across all AE terms:
	ddply(x, "AEDECOD", function(xTerm)
		if(subset(xTerm, grepl("75 mg", TRTP))$statPercN >= 20)	xTerm
	)
	# format it as a function and pass it to the 'filterFct' parameter
```

# Table export

## Export table in a Word document

The table is **exported to a Word document** (_docx_) by specifying a file name
in the **`file`** parameter.
A summary table is **shared with medical writers** via this format.

## Report or presentation

The table can be styled via the `style` parameter.
This parameter affects the fontsize, font family, color of the text and
background, dimensions of the table.

By default, the table is styled for a CSR report.

```{r style-report}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)")
	)

```

The table can also be styled for a presentation.
In this case, the color/style follows _Galapagos_ style guidelines.

```{r style-presentation}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		style = "presentation"
	)

```

Note: specific parameters can be used to export the table as
landscape (`landscape`), specify custom margins (`margin`), row indent
(`rowVarPadBase`), font size and family (`fontsize` and `font`).

## Details on the output format {#outputFormat}

The `getSummaryStatisticsTable` function **returns a
[`flextable`](https://cran.r-project.org/package=flextable) object (see
`?flextable`)**.

When printed into the R console, this object is displayed in the browser. This
object can be inserted within a `rmarkdown` document by printing it in the
specified document chunk. 
To include `flextable` in a `rmarkdown` document, `flextable` version >= 0.4.7 and for a
`docx` document: [pandoc](https://pandoc.org/installing.html) version >= 2.0 and `pptx` document: pandoc version >= 2.4 are required.

A `rmarkdown` chunk can contains only one `flextable` object. To include a list
of `flextable` in a `rmarkdown` document, the function `knitPrintListObjects` of
the `glpgUtilityFct` package can be used.

## Output the table as `data.frame`

The supporting data displayed in the `flextable` object is outputted to a R
`data.frame` if `outputType` is set to `data.frame`.

```{r outputType}

	summaryTable <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		style = "presentation",
		outputType = "data.frame"
	)
	kable(summaryTable)

```

## Intermediary table in long format

The supporting data for the summary statistics table, including
the entire set of statistics (as numeric) and combined statistic set
is accessed via the
`computeSummaryStatisticsTable`.

Please note the presence of the `isTotal` column,
which flags the records containing the number of subjects
reported in the table header.

```{r computeSummaryStatisticsTable}

	summaryTable <- computeSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)")
	)
	subset(summaryTable, isTotal)
	
```	

# Data pre-processing

The variables used for the row and columns of the summary statistics tables
should be present in a long format in the input data for
the `getSummaryStatisticsTable` function.

In case the grouping of the rows/columns is more complex and no
grouping variable is yet available in the data,
the function `combineVariables` offers simpler functionalities to
create the input data.

The label for the grouping is extracted from the SAS dataset labels if
`labelVars` is specified, or can be customized (`label` parameter).

For example, the adverse events are counted for different population set:
screened population, completer population, only events with high severity,
or related to the treatment and with high severity.

```{r combineVariables}

	# prepare the data: create grouping of interest
	dataAEGroup <- combineVariables(
		data = dataAEInterest,
		newVar = "AEGRP",
		paramsList = list(
			# for all screened patients
			list(var = "SCRNFL", value = "Y"),
			# only for completers patients
			list(var = "COMPLFL", value = "Y"),
			# for high severity
			list(var = "AESEVN", value = 2, fctTest = ">=", labelExtra = "higher than 2"),
			# treatment-emergent and with higher severity
			list(
				exprs = 'AREL == "Related" & AESEVN >= 2',
				label = paste(
					labelVars["AREL"], 
					"with", labelVars["AESEV"], "higher than 2"
				)
			),
			list(var = "AENDY", label = paste("With adverse events ending date"))
		),
		# include also counts for all records
		includeAll = TRUE, labelAll = "All Adverse events", 
		labelVars = labelVars
	)
	labelVars["AEGRP"] <- "Patient groups of interest"
	
	# create the table
	getSummaryStatisticsTable(
		data = dataAEGroup,
		colVar = "TRTA", 
		rowVar = "AEGRP", 
		labelVars = labelVars,
		dataTotal = dataTotalAE,
		stats = list(expression(paste0(statN, " (", round(statPercN, 1), ")"))),
		title = "Table: Adverse events: counts for groups of interest",
		footer = "Statistics: n (%)"
	)

```

# Visualization

Summary statistics can be visualized via **error bars** by:

* extracting the summary statistics table with the
  `computeSummaryStatisticsTable` function (used for `getSummaryStatistics` function)
* visualizing the summary statistics via the `subjectProfileSummaryPlot`
  function

```{r visualization, out.width = "100%", fig.height = 6, fig.width = 9}

	summaryTableDf <- computeSummaryStatisticsTable(
		data = dataPP,
		var = "AVAL",
		rowVar = "PARAM",
		colVar = c("TRTP", "AVISIT")
	)

	# create the plot
	subjectProfileSummaryPlot(
		data = subset(summaryTableDf, !isTotal),
		xVar = "AVISIT",
		colorVar = "TRTP",
		labelVars = labelVars,
		facetVar = "PARAM",
		useLinetype = TRUE
	)

```

# Appendix

## Session information

```{r includeSessionInfo, echo = FALSE}

	pander(sessionInfo())

```
