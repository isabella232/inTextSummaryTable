---
title: "Introduction to the `inTextSummaryTable` package"
author: "Laure Cougnaud"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: glpgStyle::html_report
vignette: >
  %\VignetteIndexEntry{Introduction to the inTextSummaryTable package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

```{r options, echo = FALSE}
	
	library(knitr)
	opts_chunk$set(
		echo = TRUE, results = 'markup', warning = FALSE, 
		# stop document execution if error (not the default)
		error = FALSE, 
		message = FALSE, cache = FALSE,
		fig.width = 8, fig.height = 7,
		fig.path = "./figures_vignette/",
		fig.align = 'center')
	options(width = 170)
	# instead of warn = 0 by default
	# include warnings when they occur in the document
	options(warn = 1)
	
```

The package `inTextSummaryTable` contains functionalities to **create
complex table of summary statistics or counts of metrics of interest**, to
**format them as in-text table for the Clinical Study Report**.

These tables can be included into a `rmarkdown` document, to be
converted into `html`, `docx` and `pptx`.
Each table can be exported into a `docx` document.

```{r loadPackages}

	library(inTextSummaryTable)
	library(pander)

```

## Data format

The input data for the creation of summary table should be a **data.frame**,
usually loaded from _SAS_ data file (`sas7bdat` format).
The label of the variables stored in the `SAS` datasets is also used
for the title/captions. 

Example datasets from the _Pelican_ study included in the
`glpgpUtilityFct` package are used for demonstration in the
vignette.  

Note that the `loadDataADaMSDTM` function of the `glpgUtilityFct` package can
be used to your custom `SAS` dataset(s) of interest.

```{r loadData}	
	
	library(glpgUtilityFct)
	library(tools)# toTitleCase

	# load example data
	data(ADaMDataPelican)
	data(labelVarsADaMPelican)
	
	dataAll <- ADaMDataPelican
	labelVars <- labelVarsADaMPelican

```

# Summary table

The main workhorse function is: **`getSummaryStatisticsTable`** which creates an
in-text table of summary statistics for variable(s) of interest.

## General type: summary statistics and/count table

Two types of table can be created: a count or summary table.

By default, the type of the table is **automatically detected** based on the
variable type. This can also be specified via the `type` parameter set to:
`summaryTable`, `countTable` or `auto` (by default, mixed type).

Note: all functionalities described below for the summary statistics table are
also available for the count table (and vice versa).

The _Demographic_ data (`ADSL` dataset) is used as example for the summary
statistics table.

```{r data-SL}

	dataSL <- dataAll$ADSL

```

### Count table

A **count table for discrete variable** (integer, factor, character) indicates
the counts of the number of subjects or records per category of interest (if
\code{var} is specified)

#### Simple count table

If **no variable is specified** (`var` parameter), the number of
subjects (`statN`)/records (`statm`) and percentage of subjects (`statPercN`)
are counted in the **entire dataset**.

(The `statPercTotalN` contains the denominator 'total' used for the
percentage computation.)

```{r count-simple}

	getSummaryStatisticsTable(data = dataSL)

```

Please note that this is equivalent of setting (`var = 'all'`).

#### Count table of categories

If a **variable is specified** via the `var` parameter, the **counts of each
sub-category/class** of the specified variable are extracted.

```{r count-categories}

	getSummaryStatisticsTable(data = dataSL, var = "SEX")

```

To include categories which are not present in the data:

* all categories to include should be specified within the levels of the `var`
factor variable
* the `varInclude0` should be set to `TRUE` or to the specific variable: `var`
(in case categories not present in the data should only be included for a subset of the variables)

```{r count-categories-empty}

	dataSLExample <- dataSL
	
	# 'SEX' formatted as character with only male
	dataSLExample$SEX <- "M" # only male
	getSummaryStatisticsTable(data = dataSLExample, var = "SEX")
	
	# 'SEX' formatted as factor, to include also female in the table
	# (even if not available in the data)
	dataSLExample$SEX <- factor("M", levels = c("F", "M"))
	getSummaryStatisticsTable(data = dataSLExample, var = "SEX", varInclude0 = TRUE)
	# or:
 	getSummaryStatisticsTable(data = dataSLExample, var = "SEX", varInclude0 = "SEX")

```

#### Count table for 'flag'-variables

For **'flag' variable** (typically ending with 'FL' in _ADaM_ or _SDTM_ format),
only the counts for the 'flagged' records are typically of interest.
Such variables typically contain only the following values:

* 'Y' if the criteria is fulfilled
* 'N' if the criteria is not is fulfilled
* '' if the value is missing

If such variables are specified via the `varFlag` parameter,
only the counts for the corresponding flagged records (records with 'Y')
are displayed in the table.

```{r count-flag-variables}

	varFlag <- grep("FL$", colnames(dataSLExample), value = TRUE)
	getSummaryStatisticsTable(
		data = dataSLExample,
		var = varFlag,
		varFlag = varFlag
	)

```

#### Inclusion of total across categories

```{r count-varTotalInclude}

	getSummaryStatisticsTable(data = dataSL, var = "SEX", varTotalInclude = TRUE)

```

### Summary statistics table {#stats-default}

**A summary statistics table** indicates **standard distribution statistics** of a continuous
 variable: mean, median, minimum, maximum, standard error, standard deviation, and count
  statistics across subjects.
Please note that **missing records for the variable are filtered**, so 
the **count statistics** (number of subjects, records, percentage) are
based **only on the non missing records**.
  
For a continuous variable, the presence of different values for the same subject 
(and across row/column variables) are checked and an appropriate error message
is returned if multiple different values are available.

If `var` parameter is set to a numeric variable of interest, its summary
statistics are displayed.

```{r numeric}

	getSummaryStatisticsTable(data = dataSL, var = "AGE")

```

### Mixed table

Summary statistics are extracted for a combined set of discrete and numeric variables.

```{r mixedTable}

	getSummaryStatisticsTable(
		data = dataSL, 
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL", "RACE", "SEX")
	)

```

## Statistics of interest

The set of summary statistics can be combined and the format customized via the `stats` 
parameter. 

This parameter is an list of `expression` of the statistics (columns) computed by default (`stat[X]` variable(s)).

Please see ? `inTextSummaryTable-stats` for an extensive documentation on the 
specification of statistics in the in-text table package.

If an unique statistic expression is specified, the 'Statistic' column doesn't appear 
in the table. In case multiple statistics are specified, these are included as separated row.

### Default sets of statistics

#### `getStats`

A common default set of statistics is available via the `getStats` function
which can be passed directly to the `stats` function.

For a continuous variable, it is **recommended to pass also the
variable to the `getStats` function** to get
standard number of number of decimals 
(see section \@ref(numberDecimalsContinuousVariable)).

```{r getStats}

	## count table:

	# count: n, '%' and m
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = getStats("count")
	)

	# n (%)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = getStats("n (%)")
	)
	
	# n/N (%)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = getStats("n/N (%)")
	)
	
	## continuous variable
	
	# all summary stats
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("summary")
	)
	
	# median (range)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("median (range)")
	)
	
	# median and (range) in a different line:
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("median\n(range)")
	)
	
	# mean (se)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = getStats("mean (se)")
	)

```

#### `getStatsData`

To get the default statistics for a **set of variables** of interest in a dataset, 
the function `getStatsData` is used:

```{r getStatsData}
library(glpgUtilityFct)
data(ADaMDataPelican)
getStatsData(data = ADaMDataPelican$ADSL, var = c("SEX", "WEIGHTBL"))
```

### Change formatting of the statistics

To change the formatting of the statistics,
the `stats` parameter should contain an expression
of the default set of statistics (see [section](#stats-default) for numeric variable).

#### For the entire table

For example, the following count table is restricted to the number of subjects per categories:

```{r stats-N}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("RACE", "SEX"),
		stats = list(N = expression(statN))
	)

```

The summary statistics table is restricted to the median and range:

```{r stats-meanSE}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL"),
		varGeneralLab = "Parameter", statsGeneralLab = "",
		colVar = "ACTARM",
		stats = list(
			`median` = expression(statMedian),
			`(min, max)` = expression(paste0("(", statMin, ",", statMax, ")"))
		)
	)

```

#### By variable/group

The statistics can also be provided for each variable separately:

```{r statExtra-EachVariable}
		
	getSummaryStatisticsTable(
		data = dataSL, 
		var = c("AGE", "RACE"),
		stats = list(
			AGE = getStats("median (range)"),
			RACE = getStats("n (%)")
		)
	)

```

### Extra statistics

Extra statistics (not available in the default set of statistics) should 
be specified via the `statsExtra` parameter.

A set of extra utility functions to compute common extra statistics are 
also available in the package:

* coefficient of variation with the `cv` function
* geometric mean with the `geomMean` function
* geometric standard deviation with the `geomSD` function
* geometric coefficient of variation with the `geomCV` function

```{r statsUtilityFct}

	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		# specify extra stats to compute
		statsExtra = list(
			statCV = cv,
			statGeomMean = geomMean,
			statGeomSD = geomSD,
			statsGeomCV = geomCV
		)
	)

```

Full customized statistics can also be provided.
For example, if you would like to specify your own formula
for the coefficient of variation:

```{r statsExtra}

	# include the coefficient of variation via the 'statsExtra' parameter
	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		statsExtra = list(statCVPerc = function(x) sd(x)/mean(x)*100)
	)

```

These statistics are then available for customization via the `stats` parameter.

```{r statsExtra-stats}

	# format the statistics with the 'stats' parameter
	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		statsExtra = list(statCVPerc = function(x) sd(x)/mean(x)*100),
		stats = list(Mean = expression(statMean), 'CV%' = expression(statCVPerc))
	)

```

### Number of decimals

To specify fixed amounts of digits for the statistics to be displayed in the table, 
the statistics are formatted in the `stats` parameter.

The number of decimals is based by default from the rules specified by the Mock Standard SAP
(_GLPGS_Mock Standards_v1.0_FINAL.docx_ document, from 5/02/2020).

#### `getStats` function

##### Categorical variable

According to the Mock SAP, the counts of number of subjects is reported
without decimals.
The number of decimals for the percentages
is specified below:

```{r nDecimals-catVar-SAP-phase23, echo = FALSE, fig.cap = "Standard Layout for Frequency Tabulations of Categorical Variables<br>(_GLPGS_Mock Standards_v1.0_FINAL.docx_ document, from 5/02/2020)"}
include_graphics("./images/nDecimals_catVar_SAP_phase23.png")
```

When the `getStats` function is used,
the counts for a categorical variables are formatted as specified above:

* the number of subjects is displayed with 0 digits (`nDecN` is set to 0)
* the frequency percentage is implemented in the `formatPercentage` function

```{r getStats-count}

	# Internal rule for the number of decimals for the percentage
	formatPercentage(c(NA, 0, 100, 99.95, 0.012, 34.768))
	
	# Used by default in the 'getStats' function
	getStats(type = "count")

```

##### Continuous variable {#numberDecimalsContinuousVariable}

The number of decimals for individual values is based on the Mock SAP (see tables below)
unless the number of digits in the database is lower. In this case, the resolution of the specified values is used.

```{r nDecimals-numVar-SAP-phase23, echo = FALSE, fig.cap = "Standard Layout for Descriptive Statistics of Continuous Variables<br>(_GLPGS_Mock Standards_v1.0_FINAL.docx_ document, from 5/02/2020)"}
include_graphics("./images/nDecimals_numVar_SAP_phase23.png")
```

In the package: 'Very small values' are considered values below 1.

When specifying the default set of available statistics with the `getStats` function,
and **only if the variable is specified** (`x` parameter),
the number of decimals for a continuous variable is determined by:

1. Extracting the number of decimals for individual values based on:
    + **pre-defined rules** based on the number of decimals of the individual values (`getNDecimalsRule` function)
    + the number of decimals **available in the input data** via the `getNDecimalsData` function
    + taking the **minimum of these two criterias** (`getNDecimals` function), 
    such as the number of decimals according
    the rule won't be higher that the actual number of decimals available in the data
2. Taking the **maximum number of decimals** across all individual values via the `getMaxNDecimals` function, 
which is used as 'base' number of decimals considered for the summary statistics
3. The actual number of decimals for each statistic is extracted (based on the Mock TLFs) by adding
to the 'base' number of decimals:
    + **0 extra decimal for the minimum, maximum**
    + **1 extra decimal for the mean, median, sd**
    + **2 extra decimals for SE**

Please note that if a different framework than implemented in steps 1 and 2
should be used for the extraction of the number of decimals for a specific variable,
the number of decimals of interest can be fixed via the `nDecCont` parameter.

```{r getMaxNDecimals}

	# %FEV1 at baseline
	print(dataSL$PFEVBL)
	
	## Extract the number of decimals for each value:
	
	# based on pre-defined rule, this metric should be displayed with 1 decimal:
	getNDecimalsRule(x = dataSL$PFEVBL)
	
	# but available in the data only with 0 decimals
	getNDecimalsData(x = dataSL$PFEVBL)
	
	# The minimum of the #decimals based on the data and pre-defined rule is:
	getNDecimals(x = dataSL$PFEVBL)
	
	## Take the maximum number of decimals 
	getMaxNDecimals(x = dataSL$PFEVBL)
	
	## Custom set of statistics are extracted when x is specified:
	getStats(x = dataSL$PFEVBL)
	
	# To fix the number of decimals:
	getStats(type = "summary", nDecCont = 1)
	
	## Create summary statistics table
	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "PFEVBL"),
		stats = list(
			AGE = getStats(type = "median (range)", x = dataSL$AGE),
			PFEVBL = getStats(type = "median (range)", x = dataSL$PFEVBL)
		)
	)

```

Notes: by default the `round` function in R rounds the number to the even number in case of 0.5. 
The `roundCustomText` function rounds to the closest digit.

#### Custom `stats` function (Advanced)

A  custom function can be created to create custom statistics with fixed number of digits.

For example, the AGE is displayed with 1 digit and the height with two digits:

```{r stats-digits}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(
			AGE = list(Median = expression(roundCustomText(statMedian, 1))),
			HEIGHT = list(Median = expression(roundCustomText(statMedian, 2)))
		)
	)

```

To create the `stats` parameter for a specific number of digits,
a custom function can be created:

```{r stats-digits-complex}

	# wrapper function to include median with specific number of digits
	# and min/max with specified number of digits - 1
	statsDMNum <- function(digitsMin)
		list('Median (range)' = 
			bquote(paste0(
				roundCustomText(statMedian, .(digitsMin+1)), 
				" (", roundCustomText(statMin, .(digitsMin)), ",", 
				roundCustomText(statMax, .(digitsMin)),
				")"
			))
	)

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL", "RACE", "SEX"),
		stats = list(
			AGE = statsDMNum(0),
			HEIGHT = statsDMNum(1),
			WEIGHTBL = statsDMNum(1),
			BMIBL = statsDMNum(1),
			RACE = getStats("n (%)"),
			SEX = getStats("n (%)")
		)
	)

```

### Statistics layout

The layout of the statistics is specified via the `statsLayout` parameter.  

By
default, the statistics are included in rows, after each element of the row
variable(s).

```{r statsLayoutRow}

	# statsLayout = 'row'
	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE))
	)
	
```

The statistics can also be included in columns.

```{r statsLayoutCol}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE)),
		statsLayout = "col"
	)

```

The statistics can also be specified in different rows, but in a separated column.

```{r summaryTable-PP-medianMinMax-statsLayoutRowVarInSepCol}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE)),
		statsLayout = "rowInSepCol"
	)

```

By default, if only one statistic is available in the table,
the name of the statistic is not included in the rows/columns,
as the statistic is generally described in this case in the title
of the table.

```{r summaryTable-statsLayout-onlyOneStat}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean))
	)

```

To include even in this case the name of the statistic, the 
parameter `statsLabInclude` should be set to `TRUE`.

```{r summaryTable-statsLayout-onlyOneStat-statsLabInclude}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean)),
		statsLabInclude = TRUE
	)

```

## Table layout

Grouping variable can be specified in the vertical direction (across rows) or
in the horizontal direction (across columns).

If no variables are specified in `var`, counts across row/column variable
are displayed.

The adverse events dataset is used for demonstration.

```{r countTable-AE-data}
				
	dataAE <-  subset(dataAll$ADAE, FASFL == "Y" & TRTEMFL == "Y")
	dataAEInterest <- subset(dataAE, AESOC %in% c("Infections and infestations", "General disorders and administration site conditions", "Ear and labyrinth disorders"))

	# ensure that order of elements is the one specified in the corresponding numeric variable
	library(glpgUtilityFct)
	dataAEInterest <- convertVarToFactor(
		data = dataAEInterest, 
		var = c("TRTP", "AESEV"),
		varNum = c("TRTPN", "AESEVN")
	)

```

### Row and column variables

Specific grouping variable(s) for the columns can be specified via the
**`colVar`** parameter and for the rows via the **`rowVar`** parameter.

If multiple category variables are specified, they should be specified in
hierarchical order.

```{r rowVarColVar}

	# unique row variable
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = "AEDECOD",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# multiple nested row variables
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# unique column variable
	getSummaryStatisticsTable(
		data = dataAEInterest,
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# combination of rows and columns
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars,
		colHeaderTotalInclude = FALSE
	)

```

### Row variable

By default (when `outputType` is set to: 'flextable'), if multiple row variables are specified, 
they are considered nested
and displayed in the first column of the final table.
Each sub-category is indicated with a specific indent (customizable with
`rowVarPadBase`).

#### Variable in separated column

**Row variables** that shouldn't be included in the unique column with the row
variables, but as **separated column** are additionally specified via the
`rowVarInSepCol` parameter.

```{r rowVarInSepCol}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD", "AESEV"),
		rowVarInSepCol = "AESEV",
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
```

#### Row ordering

The **categories in the row variables can be ordered** based on the
**`rowOrder`** variable. 

This variable is either:

* a string with the name of an implemented method to order the rows, among:
     + `alphabetical`: categories are ordered **alphabetically**
     + `auto`: categories are ordered based on the **levels** if the input variable is a factor, 
     alphabetically otherwise
     + `total`: categories are ordered based on the 'total' column (see \@ref(colTotal)) 
     (computed even if not included in the table)
* a custom ordering function to apply in the data to order the rows

##### Common order for all row variables

```{r rowOrder-common}

	# 'auto':

	# set order of SOC to reverse alphabetical order
	dataAEInterest$AESOC <- factor(
		dataAEInterest$AESOC, 
		levels = rev(sort(unique(dataAEInterest$AESOC)))
	)
	# AEDECOD is not a factor -> sort alphabetically by default
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# total counts
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE, colTotalLab = "Number of subjects",
		rowOrder = "total",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	# same order even if the 'total' column is not specified
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", 
		rowOrder = "total", 
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

##### Different orders for each row variable

In case the order should be different for each row variable, a named list is
provided for the `rowVar` parameter.

```{r rowOrder-specific}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", #colTotalInclude = TRUE,
		rowOrder = c(AESOC = "alphabetical", AEDECOD = "total"),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

##### Row order based on the total of a column category

If the row categories should be **ordered by total counts for a specific
category of the column variable(s)**, a function **`rowOrderTotalFilterFct`** is
specified.

The adverse events are sorted based on the incidence in the treated group.

```{r rowOrder-rowOrderTotalFilterFct}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		rowOrder = "total",
		stats = getStats("n (%)"),
		labelVars = labelVars,
		# consider only the counts of the treated patients to order the rows
		rowOrderTotalFilterFct = function(x) subset(x, TRTP == "treatmentX")
	)

```

##### Row order based on a custom specified function

If the method to order the rows is more complex, the `rowOrder` parameter specifies
a function taking the summary table as input and returning the order
levels of the elements in the row variable.

For example, the adverse event table is sorted based on the counts of patient
presenting this event across all treatment classes, and in case of ties based on 
the counts of treated-patients presenting this event.

```{r rowOrder-function-example1}

	library(plyr)
	getSummaryStatisticsTable(
		data = dataAEInterest,
		type = "count",
		rowVar = "AEHLT",
		rowOrder = function(x){
			x <- subset(x, !isTotal)
			totalAcrossTreatments <- subset(x, TRTP == "Total")
			# counts across treated patients
			totalForTreatmentOnly <- subset(x, TRTP == "treatmentX")
			dataCounts <- merge(totalAcrossTreatments, totalForTreatmentOnly, by = "AEHLT", suffixes = c(".all", ".treat"))
			# sort first based on overall count, then counts of treated patients
			dataCounts[with(dataCounts, order(`statN.all`, `statN.treat`, decreasing = TRUE)), "AEHLT"]
		},
		colVar = "TRTP", colTotalInclude = TRUE,
		labelVars = labelVars,
		title = "Table: Adverse Events ordered based on total counts",
		stats = list(expression(paste0(statN, " (", round(statPercN, 1), ")"))),
		footer = "Statistics: n (%)"
	)

```

The adverse event table is now ordered based on the counts in the placebo, then
treated-patients column, for the organ class and the adverse event term separately.

```{r rowOrder-function-example2}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		rowOrder = list(
			AESOC = function(table){
				# records with total for each AESOC
				nAESOCPlacebo <- subset(table, !isTotal & grepl("placebo", TRTP) & AEDECOD == "Total")
				nAESOCTreat <- subset(table, !isTotal & grepl("75 mg", TRTP) & AEDECOD == "Total")
				nAESOCDf <- merge(nAESOCPlacebo, nAESOCTreat, by = "AESOC", suffixes = c(".placebo", ".treatment"))
				nAESOCDf[with(nAESOCDf, order(`statN.placebo`, `statN.treatment`, decreasing = TRUE)), "AESOC"]
			},
			AEDECOD = function(table){
				# records with counts for each AEDECOD
				nAEDECODPlacebo <- subset(table, !isTotal & grepl("placebo", TRTP) & AEDECOD != "Total")
				nAEDECODTreat <- subset(table, !isTotal & grepl("75 mg", TRTP) & AEDECOD != "Total")
				nAEDECODDf <- merge(nAEDECODPlacebo, nAEDECODTreat, by = "AEDECOD", suffixes = c(".placebo", ".treatment"))
				nAEDECODDf[with(nAEDECODDf, order(`statN.placebo`, `statN.treatment`, decreasing = TRUE)), "AEDECOD"]
			}
		),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

#### Row variable labels

##### Based on dataset

The **labels used for the variables parameter** (row variables) **are
automatically extracted from the labels** contained in the _SAS_ dataset, by
specifying the `labelVars` parameter.

```{r summaryTable-PP-rowVarWithLabel-labelVars}

	# combination of rows and columns
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
```

##### Custom

The label can also be specified directly via the `rowVarLab` parameter,
for each variable in `rowVar`.

If an unique row label should be used (even if multiple row variables are
specified), `rowVarLab` is set to this unique label.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		labelVars = labelVars
	)
	
```

### Include empty row/columns

The parameters **`rowInclude0` and `colInclude0`** are set to TRUE to 
**include statistics for empty categories** within the row/column. 

These categories are specified via additional **levels in the `rowVar`/`colVar` factor variables**.

```{r countTable-emptyVars}

	## only consider White blood cell adverse events
	dataAESubset <- subset(dataAE, AEHLT == "Viral infections NEC")
	
	## create dummy categories for:
	# treatment
	dataAESubset$TRTP <- with(dataAESubset, 
		factor(TRTP, levels = c(unique(as.character(TRTP)), "Treatment B"))
	)
	# low-level term category
	dataAESubset$AELLT <- with(dataAESubset, 
		factor(AELLT, levels = c(unique(as.character(AELLT)), "Lymphocyte percentage increased"))
	)
	
	# create summary statistics table
	getSummaryStatisticsTable(
		data = dataAESubset,
		type = "count",
		rowVar = c("AEHLT", "AELLT"),
		rowInclude0 = TRUE, colInclude0 = TRUE,
		colVar = "TRTP",
		labelVars = labelVars,
		title = "Table: Adverse Events: white blood cell analyses",
		stats = getStats("n (%)"),
		footer = "Statistics: n (%)"
	)

```


### Layout for summary statistics variables

#### Default

The **variable(s) used for the summary statistics** 
(`var`) are included **by default in rows**.

```{r summaryTable-layout-var}

	dataPFEV1 <- subset(dataAll$ADRE, FASFL == "Y" & PARAMCD == "FEV1PP" & AN01FL == "Y")
	dataPFEV1 <- convertVarToFactor(
		data = dataPFEV1, 
		var = c("TRTP", "AVISIT"),
		varNum = c("TRTPN", "AVISITN")
	)
	getSummaryStatisticsTable(
		data = dataPFEV1,
		var = c("AVAL", "CHG", "PCHG"),
		colVar = c("TRTA"),
		rowVar = "AVISIT",
		labelVars = labelVars,
		stats = getStats("summary-default")
	)

```

#### Summary variable in columns

In case multiple variables are to be summarized, the different variables can be included in 
different columns by including the specific label: 'variable' in `colVar`.
Beware that such layout only makes sense for variables
with similar types (e.g. all numeric variables).

```{r summaryTable-layout-varInColumn}

	dataPFEV1 <- subset(dataAll$ADRE, FASFL == "Y" & PARAMCD == "FEV1PP" & AN01FL == "Y")
	dataPFEV1 <- convertVarToFactor(
		data = dataPFEV1, 
		var = c("TRTP", "AVISIT"),
		varNum = c("TRTPN", "AVISITN")
	)
	getSummaryStatisticsTable(
		data = dataPFEV1,
		var = c("AVAL", "CHG", "PCHG"),
		colVar = c("variable", "TRTA"),
		rowVar = "AVISIT",
		labelVars = labelVars,
		stats = getStats("summary-default")
	)

```

#### Inclusion of summary variables in case one variable is specified

By default, the variable label is not included if only one summary
statistic variable is specified.

```{r summaryTable-layout-var-oneLabel-default}
		
	getSummaryStatisticsTable(data = dataSL, var = "AGE", colVar = "TRT01P")

```

To include the label in case only one summary statistic variable
is specified, the parameter `varLabInclude` should be set to TRUE.

```{r summaryTable-layout-var-oneLabel-varLabInclude}
		
	getSummaryStatisticsTable(
		data = dataSL, 
		var = "AGE", 
		varLabInclude = TRUE,
		colVar = "TRT01P"
	)

```

### Inclusion of the count per group in case of missing values

It might be of interest to display the counts of all subjects per
row/column variable in association of the summary statistic 
of a variable of interest.

For example it could be of interest to report the total number of subjects
per group, which could differ from the total number of subjects 
for a variable of interest if this variable contain missing values.

```{r summaryTable-layout-var-empty}

	dataAEInterestWC <- ddply(dataAEInterest, c("AEDECOD", "USUBJID", "TRTA"), function(x){
		x[which.max(x$AESEVN), ]
	})
	dataAEInterestWC[1, "AESEVN"] <- NA
    getSummaryStatisticsTable(
        data = dataAEInterestWC,
        colVar = "TRTA",
        rowVar = "AEBODSYS",
        var = c("AESEVN", "all")
    )

```

## Total

The **total number of subjects** is displayed in the **column header**
and used for the **computation of the percentages** in the table body.

### External dataset

By default, this total is extracted from the **available number of subjects** 
in the input `data`.

 If the total should be extracted
from a **different dataset**, e.g. if only a subset of the patients are present
in the data, it should be specified via the **`dataTotal`** variable (by default set to `data`).

For example, the total number of patients per treatment arm is extracted from the 
subject-level (`ADSL`) dataset. 

```{r countTable-LB-customDenominator}

	# dataset used to extract the 'Total'
	dataTotalAE <- subset(dataAll$ADSL, TRT01A != "Screen Failure")
	# should contain columns specified in 'colVar'
	dataTotalAE$TRTA <- dataTotalAE$TRT01A 
	
	# by default, total number of subjects extracted from data
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		labelVars = labelVars
	)
	# and on dataTotal if specified:
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

### Computation of the percentage

#### Dataset

A different dataset used for the computation of the percentage can be specified
via the `dataTotalPerc` (by default set as `dataTotal`).
If the total number of subjects differ between the components of the table, 
the extra row/column(s) variable(s) are specified via `colVarTotalPerc`/`rowVarTotalPerc`.

For example, in the table of shift of worst-case laboratory abnormalities: the total number
of subjects for the computation of the percentage are extracted based on the number of subjects 
with available post-dose measurements **per laboratory parameter**.

```{r rowVarTotalPerc}

	dataLB <- subset(dataAll$ADLB, FASFL == "Y" & PARAMCD %in% c("BACT", "ALB"))
	
	# worst-case scenario with abnormalities
	dataLBWC <- subset(dataLB, AVISIT == "Worst-case post-baseline" & SHIFT1 != "")

	# data considered for the total
	dataLBPostBaseline <- subset(dataLB, !AVISIT %in% c("Baseline", "Screening", "Worst-case post-baseline"))
	
	# post-baseline measurements  are not available for all subjects 
	kable(aggregate(USUBJID ~ PARAM + TRTA, data = dataLBPostBaseline, function(x) length(unique(x))))
	
	# by default, the same total number of subjects 
	# per treatment is used across all rows/parameters
	getSummaryStatisticsTable(
		data = dataLBWC,
		colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
		stats = getStats("n (%)"),
		emptyValue = 0, rowAutoMerge = FALSE,
		dataTotal = dataLBPostBaseline
	)
	
	# percentage based on total number of subjects with available
	# post-baseline measurements PER parameter:
	getSummaryStatisticsTable(
		data = dataLBWC,
		colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
		stats = getStats("n (%)"),
		emptyValue = 0, rowAutoMerge = FALSE,
		# total for column header
		dataTotal = dataLBPostBaseline, 
		dataTotalPerc = dataLBPostBaseline,
		rowVarTotalPerc = "PARAM"
	)
	
```

#### Percentage of the number of records

If the percentage should be computed based on the number of records, instead 
of the number of subjects, the parameter: `statsPerc`
should be set to `statm` (`statN` by default).

For example, to extract the percentage of laboratory
measurements by reference range and parameter:

```{r statsPerc}
getSummaryStatisticsTable(
	data = dataLBWC,
	colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
	stats = getStats("m (%)"), statsPerc = "statm",
	emptyValue = 0, rowAutoMerge = FALSE,
	rowVarTotalPerc = "PARAM",
	# total for column header
	dataTotal = dataLBPostBaseline, 
	dataTotalPerc = dataLBPostBaseline
)
```

### Total number of subjects across columns {#colTotal}

The total of the number of subjects **across all columns** is included 
if the `colTotalInclude` is set to TRUE.

By default, the total number of subjects is extracted based on the
input dataset across columns: subjects presenting the **same event in multiple column(s) are counted once**
in the column total (e.g. for adverse event table in a context of cross-over experiment).
A different dataset for the total column can also be specified via the `dataTotalCol` parameter.

This column is by default labelled 'Total', but this can be customized with the
`colTotalLab` parameter.

```{r colTotal}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		colTotalInclude = TRUE, colTotalLab = "All subjects",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

### Row total

If the total should be included across elements of specific `rowVar`
variable(s), this(these) variable(s) should be included in `rowVarTotalInclude`.

For the first row variable, the total is included in the first row of the table,
with the label specified in `rowTotalLab`.

```{r rowVarTotalInclude1}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AESOC", rowTotalLab = "Any AE", 
		rowVarTotalInSepRow = "Any AE",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

In case multiple row variables are specified, the total can also
be included for each of this variable.
In this case, the total is by default included in the header of each category
of this variable.

```{r rowVarTotalInclude2}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD", 
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

This total can also be included as a separated category in the table, if this
variable is additionally specified in `rowVarTotalInSepRow`.

```{r rowVarTotalInclude-rowVarTotalInSepRow}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD",
		rowVarTotalInSepRow = "AEDECOD",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

A different dataset considered for the row total is specified via the 
`dataTotalRow` parameter.

For example, in the worst-case treatment-emergent adverse events table, the total
per SOC and across SOCs should count the patient once per severity class.

For example, the patient: '202-4903-03' present a moderate severity for headache, and mild severity
for the chest injury and fall, but is only counted in the once in the table total.

```{r dataTotalRow}

	dataTEAEInterest <- subset(
		dataAll$ADAE, 
		SAFFL == "Y" & TRTEMFL == "Y" &
		AESOC %in% c("Injury, poisoning and procedural complications", "Nervous system disorders")
	)

	# extract worst-case scenario data (only one record if multiple with same severity)
	dataTEAEInterestWC <- ddply(dataTEAEInterest, c("AEDECOD", "USUBJID", "TRTA"), function(x){
		x[which.max(x$AESEVN), ]
	})
	kable(ddply(dataTEAEInterestWC[, c("USUBJID", "TRTA", "AESOC", "AEDECOD", "AESEV", "AESEVN")], "USUBJID"), split.tables = Inf)

	## datasets used for the total: 
	# for total: compute worst-case across SOC and across AE term
	# (otherwise patient counted in multiple categories if present different categories for different AEs)
	dataTotalRow <- list(
		# within SOC (across AEDECOD)
		'AEDECOD' = ddply(dataTEAEInterestWC, c("AESOC", "USUBJID", "TRTA"), function(x){	
			x[which.max(x$AESEVN), ]
		}),
		# across SOC
		'AESOC' = ddply(dataTEAEInterestWC, c("USUBJID", "TRTA"), function(x){	
			x[which.max(x$AESEVN), ]
		})
	)

	getSummaryStatisticsTable(
		data = dataTEAEInterestWC,
		## row variables:
		rowVar = c("AESOC", "AEDECOD", "AESEV"), rowVarInSepCol = "AESEV",
		# include total across SOC and across AEDECOD
		dataTotal = dataTotalAE, # total for column header and denominator
		rowVarTotalInclude = c("AESOC", "AEDECOD"), 
		dataTotalRow = dataTotalRow, # data for total row
		rowVarTotalByVar = "AESEV", # count for each severity category for the total
		rowTotalLab = "Any TEAE", 
		rowVarLab = c(AESOC = "Subjects with, n(%):", AESEV = "Worst-case scenario"),
		# sort per total in the total column
		rowOrder = "total", 
		## column variables
		colVar = "TRTA", 
		stats = getStats("n (%)"),
		emptyValue = "0",
		labelVars = labelVars
	)

```

### Remove total in column header

The total number of subjects in each column is by default included.
This is not displayed if `colHeaderTotalInclude` is set to FALSE.

```{r colHeaderTotalInclude}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD",
		rowVarTotalInSepRow = "AEDECOD",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		colHeaderTotalInclude = FALSE
	)

```

## Labels

If the data is loaded into R with the `read_haven` of the `haven` package,
 or the `loadDataADaMSDTM` function of the `glpgUtilityFct` package, the label
 for each variable is stored in the 'label' attribute of the corresponding
 column.

However, if this label is lost (e.g. if the object is subsetted), 
labels are specified via the `labelVars` parameter for all variables at once, 
or via specific `[parameter]Lab` parameter, as `rowVarLab`/`colVarLab`/`varLab`
for the row/column/variable to summarize respectively.

## Title and footnote

Title and footnote are specified via the corresponding `title` and `footer` parameters.
The convenient function `toTitleCase` from the `tools` package
is used to set title case for the title of the summary statistics table.

```{r titleAndFooter}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = toTitleCase("MOR106-CL-102: Adverse Events by System Organ Class and Preferred Term (Safety Analysis Set, Part 1)"),
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		)
	)

```

## Text customization

The pharmacokinetics data is used for demonstration.

```{r data-ADSL}
	
	dataPP <- subset(dataAll$ADPP, SAFFL == "Y")
	
	# ensure that order of elements is the one specified in the corresponding numeric variable
	library(glpgUtilityFct)
	dataPP <- convertVarToFactor(
		data = dataPP, 
		var = c("PARCAT1", "PARAM", "AVISIT", "TRTP"), 
		varNum = c("PARCAT1N", "PARAMN", "AVISITN", "TRTPN")
	)
	
```	

### Superscript/subscript

Superscript and superscript are specified via the special text pattern: `a^{b}`
and subscript as `a_{b}` respectively.

To use a superscript or a subscript in
the table, the text should be formatted as:
`text^{superscript}` or `text_{subscript}`.

This is for example useful to reference additional informations in a specific
footnote or specify custom variable labels.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab-superscript}

	# format labels with subscript
	paramLabelPK <- c(
		CTROUGH = "C_{trough} (ng/mL)", 
		TLAG = "t_{lag} (h)",
		TMAX = 't_{max} (h)', 
		CMAX = "C_{max} (ng/mL)",
		AUCTAU = "AUC_{0-t} (ng.h/mL)",
		AUC08H = "AUC_{0-8h} (ng.h/mL)"
	)
	dataPP$PARAMRF <- paramLabelPK[dataPP$PARAMCD]
	
	getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 %in% c("Ivacaftor", "Lumacaftor")),
		var = "AVAL",
		colVar = c("TRTP", "AVISIT"),
		rowVar = c("PARCAT1", "PARAMRF"),
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter\nfor each compound^{(1)}", # use superscript for the foonote
			'PARCAT1' = "" 
		),
		stats = list(expression(paste0(roundCustomText(statMean, 1), "\n(", roundCustomText(statSE, 2),")"))),
		# include the footnote
		footer = c(
			"(1) Each compound is labelled according to its Galapagos compound ID.",
			paste0("AUC_{0-t} represents the ", getLabelParamcd(paramcd = "AUCTAU", data = dataPP), ".")
		)
	)	

```

### Bold and greek letters

Specific cells of the table can be highlight in bold by using the
syntax: `bold{}` in the `stats` or `statsExtra` function.

This highlighting may depend:

* on a additional variable via the `statsExtra` parameter:  
for example: `statsExtra <- function(data)   with(data, ifelse(ANRIND != "N", paste0("bold{", toString(AVAL), "}"), toString(AVAL))`
* on the values of computed statistics, via the `stats` parameter

Greek letter are included as it is in the table.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab-bold}
	
	getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 == "Lumacaftor"),
		var = "AVAL",
		colVar = c("TRTP", "AVISIT"),
		rowVar = "PARAMRF",
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter\nMean (SE*)", 
			'PARCAT1' = "Compound^{(1)}" # use superscript for the foonote
		),
		labelVars = labelVars,
		stats = list(
			expression(paste0(
				ifelse(statMean > statMedian, 
					paste0("bold{", roundCustomText(statMean, 1), "}"), 
					statMean
				), 
				"\n(", 
				roundCustomText(statSE, 2),")")
			)
		),
		# include greek letter
		footer = "*Standard error is computed as: SE = σ/√n.",
		file = file.path("tables_CSR", "Table_textCustomization.docx")
	)	

```

## Multiple table creation

Multiple tables can be created for each element of
a variable in the dataset by specifying this variable in `byVar`.

For example, pharmacokinetic tables are created for each compound:

```{r byVar}

	summaryTableList <- getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 %in% c("Ivacaftor", "Lumacaftor")),
		var = "AVAL",
		colVar = c("TRTP", "AVISIT"),
		rowVar = "PARAMRF",
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter", 
			'PARCAT1' = "Compound^{(1)}" # use superscript for the foonote
		),
		byVar = "PARCAT1", 
		labelVars = labelVars,
		stats = list(expression(paste0(roundCustomText(statMean, 1), "\n(", roundCustomText(statSE, 2),")")))
	)	
	# print the list of tables in the rmarkdown document
	glpgUtilityFct::knitPrintListObjects(summaryTableList) 

```

A list of `flextable` can be included into a `rmarkdown` document with the
`knitPrintListObjects` (see [section](#outputFormat)).
Please note that the following chunk option should be used: **`results = 'asis'`**.

## Filter records in a table

If only a subset of the records should be displayed in the final table,
a custom filtering functions is specified via the `filterFct` parameter.

```{r countTable-AE-filterFct}

	library(plyr)
		
	# SOC with AE terms with at least 2 subjects
	getSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		filterFct = function(x)
			ddply(x, "AESOC", function(y)
				if(any(y$statN >= 2))	y			
			),
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term with at least 2 patients in System Organ Class"
	)
	
	# AE term with at least one term with more than 20% in the treatment
	getSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		filterFct = function(x)
			ddply(x, "AEDECOD", function(xTerm){
				xTermTreatment <- subset(xTerm, grepl("75 mg", TRTP))
				if(xTermTreatment$statPercN >= 20)	xTerm		
			}),
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term with at least 20% patients in treatment category"
	)
	
```

Note: to help for the creation of this filtering function,
the displaying data could be extracted first via the `computeSummaryStatisticsTable`
function (instead of creating directly the in-text table via the
`getSummaryStatisticsTable`), then used to define the `filterFct` parameter.

```{r countTable-AE-filterFct- details}

	x <- computeSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	head(x)
	# for specific AEDECOD
	xTerm <- subset(x, AEDECOD == "Viral upper respiratory tract infection")
	# identify the record for treated patient:
	subset(xTerm, grepl("75 mg", TRTP))
	# keep all records (placebo + treatment) if percentage if higher than 20%:
	# if no 'else' condition, nothing (NULL) is returned:
	if(subset(xTerm, grepl("75 mg", TRTP))$statPercN >= 20)	xTerm
	# across all AE terms:
	ddply(x, "AEDECOD", function(xTerm)
		if(subset(xTerm, grepl("75 mg", TRTP))$statPercN >= 20)	xTerm
	)
	# format it as a function and pass it to the 'filterFct' parameter
```

# Table format/export

## Output formats {#outputFormat}

The `outputType` parameter specifies the output format of the summary statistics table.

### Word/PowerPoint

#### General format

To get the table in a format **suitable for _Word_/_PowerPoint_**,
the _outputType_ parameter should be set to **'flextable'** (the default).

```{r outputType-flextable}

	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		outputType = "flextable"
	)
	class(summaryTableFt)
	summaryTableFt

```

This format is available via the [`flextable` R package](https://cran.r-project.org/package=flextable) 
(see `?flextable`).

When printed into the R console, this object is displayed in the browser. 
This object can be inserted within a `rmarkdown` document by printing it 
in the specified document chunk, providing than:

* `flextable` version >= 0.4.7
* for a `docx` document (`output_type`): [pandoc](https://pandoc.org/installing.html) version >= 2.0
(see [`rmarkdown` documentation for Word](https://bookdown.org/yihui/rmarkdown/word-document.html))
* for `pptx` document: [pandoc](https://pandoc.org/installing.html) version >= 2.4 
(see [`rmarkdown` documentation for PowerPoint](https://bookdown.org/yihui/rmarkdown/powerpoint-presentation.html))

A `rmarkdown` chunk can contains only one `flextable` object. 
To include a list of `flextable` in a `rmarkdown` document, 
the function `knitPrintListObjects` of the `glpgUtilityFct` package can be used.

#### Export table to a separated file

The table can be exported to a separated file by specifying a file name in
the **`file`** parameter. 

If the format is:

* _txt_: the raw base table is exported to a text file.
This format can be used e.g. to QC with TLFs.
* _docx_: the formatted table is exported to a Word document.
Such format is typically of interest to share the tables to the medical
writers, to be imported directly into a SAP (if `style = 'report'`).
* _html_: an interactive table is exported to the specified html file

```{r file}

	# export table to a Word document
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR", "summaryTable-AEs.docx")
	)
	
	# export interactive table to a html document
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR", "summaryTable-AEs.html")
	)
	
	# export table in raw format to a text file
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR", "summaryTable-AEs.txt")
	)
	
	# export to multiple formats at once
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR",
			c("summaryTable.txt", "summaryTable.docx", "summaryTable.html")
		)
	)

```

#### Report or presentation

The table can be styled via the `style` parameter.
This parameter affects the fontsize, font family, color of the text and
background, dimensions of the table.

By default, the table is styled for a CSR report.

```{r style-report}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)")
	)

```

The table can also be styled for a presentation.
In this case, the color/style follows _Galapagos_ style guidelines.

```{r style-presentation}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		style = "presentation"
	)

```

Note: specific parameters can be used to export the table as
landscape (`landscape`), specify custom margins (`margin`), row indent
(`rowVarPadBase`), font size and family (`fontsize` and `font`).

### Interactive table: `DT`

The summary statistics table is exported as an interactive table
by setting the parameter: `outputType` to: 'DT'.
A `datatable` object, available via the [DT](https://CRAN.R-project.org/package=DT) R
package is created.

```{r outputType-DT}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		outputType = "DT"
	)

```

Interactivity includes the functionalities to:

* filter the table
* order columns
* export the table (or a subset of this)
* custom interactivity as the possibility to have expandable rows/columns, 
e.g. to include extra information (as patient profiles) of the subjects summarized in the table

Such table can be included in a _html_ `rmarkdown` report.

### `data.frame`

#### Final table

The supporting data displayed in the `flextable`/`DT` object is output to a R
`data.frame` if `outputType` is set to `data.frame`.

```{r outputType-dataframe}

	summaryTable <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		style = "presentation",
		outputType = "data.frame"
	)
	pander(summaryTable, split.table = Inf)

```

#### Full table in long format

The table with all the default computed summary statistics, specified
set of statistics of interest and all row/column variables stored in
a long format is available by using the `outputType` parameter to: 'data.frame-base'.

Because all the variables of interest are stored in a long format,
this format could be useful to compare the computed summary statistics between 
different dataset versions.

```{r outputType-dataframe-base}

summaryTableAll <- getSummaryStatisticsTable(
	data = dataAEInterest,
	rowVar = c("AESOC", "AEDECOD"),
	colVar = "TRTA",
	stats = getStats("n (%)"),
	dataTotal = dataTotalAE,
	labelVars = labelVars,
	title = "Table: Adverse Events by System Organ Class and Preferred Term",
	footer = c(
		"N=number of subjects with data; n=number of subjects with this observation",
		"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
	),
	rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
	style = "presentation",
	outputType = "data.frame-base"
)
pander(summaryTableAll, split.table = Inf)

```

### Differences between the format

Most of the functionalities and default parameters are the same
between the `flextable` and `DT` format, at the exception of:

* general layout: 
    + for the `DT` format, by default the variables and statistics are
    included in different columns: `rowVarInSepCol` is `rowVar` and `statsLayout` is set to 'col'
    + for the `flextable` format, by default the row variables and statistics are nested:
    `rowVarInSepCol` is set to: 'NULL' and the `statsLayout` is set to 'row'


## Detailed framework of the creation of the in-text table

The `getSummaryStatisticsTable` consists of the following framework:

* computation of the summary statistics table with the `computeSummaryStatisticsTable`
function
* export of the table to the required format (`outputType` parameter)

### Computation of the summary statistics

The supporting data for the summary statistics table, including
the entire set of statistics (as numeric) and combined statistic set
is accessed via the
`computeSummaryStatisticsTable`.

This is equivalent of the table output by the `getSummaryStatisticsTable`
function, with the `outputType` set to 'data.frame-base'.

```{r computeSummaryStatisticsTable}

	summaryTable <- computeSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)")
	)
	pander(summaryTable)
	
```	

Please note the presence of the `isTotal` column,
which flags the records containing the number of subjects
reported in the table header.

```{r computeSummaryStatisticsTable-isTotal}

	pander(subset(summaryTable, isTotal))
	
```	

### Export table to the requested format

The table is exported with the requested format (by default `flextable`)
with the function `exportSummaryStatisticsTable`:

* `flextable` format:
```{r exportSummaryStatisticsTable-flextable}

	exportSummaryStatisticsTable(summaryTable = summaryTable)
	
```	
* `DT` format:
```{r exportSummaryStatisticsTable-DT}

	exportSummaryStatisticsTable(summaryTable = summaryTable, outputType = "DT")
	
```	
* `data.frame` output
```{r exportSummaryStatisticsTable-data.frame}

	pander(
		exportSummaryStatisticsTable(summaryTable = summaryTable, outputType = "data.frame")
	)
	
```	

## Export table of pre-computed summary statistics

To create a table in similar format as the in-text tables created by the package,
from pre-computed summary statistics (e.g. from CRO or from a different software as _SAS_)
the function `exportSummaryStatisticsTable` is used.
This function takes as input a data.frame which should contain the 
summary statistics in a long format, in which the statistic value (`statsVar`);
statistic type (if multiple), grouping row and columns (`rowVar` and `colVar`)
are stored as different columns in the data.frame.

```{r exportSummaryStatisticsTable}

	dataPFEV1 <- subset(dataAll$ADRE, 
		FASFL == "Y" & PARAMCD == "FEV1PP" &
		(
			AVISIT == "Baseline" |
			# retain only: valid spirometry assessment (CRIT1)
			(AVISIT %in% c("Day 14", "Day 28", "Follow-up") & CRIT1FL == "Y")
			)
	)
	
	# create example of data.frame containing statistics of interest
	statsEff <- sapply(c("AVAL", "CHG"), function(var){
		getStats(
			type = c("n", "mean (se)", "median (range)"),
			x = dataPFEV1[[var]]
		)
	}, simplify = FALSE)
	summaryTable <- computeSummaryStatisticsTable(
		data = dataPFEV1,
		colVar = c("TRTP", "AVISIT"),
		var = c("AVAL", "CHG"), varGeneralLab = "",
		stats = statsEff,
		labelVars = labelVars
	)
	
	# format df with statistics to in-text tables format
	exportSummaryStatisticsTable(
		summaryTable = summaryTable,
		statsVar = c("Mean (SE)", "Median (range)"),
		rowVar = "variable", rowVarLab = "Statistic",
		colVar = c("TRTP", "AVISIT"),
		colHeaderTotalInclude = TRUE,
		labelVars = simpleCap(tolower(labelVars[c("AVAL", "CHG")])),
		title = toTitleCase("Table: Sweat chloride inferential statistics of the changes from baseline per time point (pharmacodynamics analysis Set, Mean Value from both arms)"),
		file = file.path("tables_CSR", "Table_SweatChlorideChangeFromBaseline_inferential.docx")
	)

```

If the column headers should contain total number of subjects, 
the corresponding counts should be stored in records with the column `isTotal` set to TRUE.

# Data pre-processing

The variables used for the row and columns of the summary statistics tables
should be present in a long format in the input data for
the `getSummaryStatisticsTable` function.

In case the grouping of the rows/columns is more complex and no
grouping variable is yet available in the data,
the function `combineVariables` offers simpler functionalities to
create the input data.

The label for the grouping is extracted from the SAS dataset labels if
`labelVars` is specified, or can be customized (`label` parameter).

For example, the adverse events are counted for different population set:
screened population, completer population, only events with high severity,
or related to the treatment and with high severity.

```{r combineVariables}

	# prepare the data: create grouping of interest
	dataAEGroup <- combineVariables(
		data = dataAEInterest,
		newVar = "AEGRP",
		paramsList = list(
			# for all screened patients
			list(var = "SCRNFL", value = "Y"),
			# only for completers patients
			list(var = "COMPLFL", value = "Y"),
			# for high severity
			list(var = "AESEVN", value = 2, fctTest = ">=", labelExtra = "higher than 2"),
			# related and with higher severity
			list(
				exprs = 'AREL == "Related" & AESEVN >= 2',
				label = paste(
					labelVars["AREL"], 
					"with", labelVars["AESEV"], "higher than 2"
				)
			),
			list(var = "AENDY", label = paste("With adverse events ending date"))
		),
		# include also counts for all records
		includeAll = TRUE, labelAll = "All Adverse events", 
		labelVars = labelVars
	)
	labelVars["AEGRP"] <- "Patient groups of interest"
	
	# create the table
	getSummaryStatisticsTable(
		data = dataAEGroup,
		colVar = "TRTA", 
		rowVar = "AEGRP", 
		labelVars = labelVars,
		dataTotal = dataTotalAE,
		stats = list(expression(paste0(statN, " (", round(statPercN, 1), ")"))),
		title = "Table: Adverse events: counts for groups of interest",
		footer = "Statistics: n (%)"
	)

```

# Visualization

Summary statistics can be visualized via **error bars** by:

* extracting the summary statistics table with the
  `computeSummaryStatisticsTable` function (used for `getSummaryStatistics` function)
* visualizing the summary statistics via the `subjectProfileSummaryPlot`
  function
  
```{r visualization-extractData}

	summaryTableDf <- computeSummaryStatisticsTable(
		data = dataPP,
		var = "AVAL",
		rowVar = c("PARCAT1", "PARAM"),
		colVar = c("TRTP", "AVISIT")
	)

```

## With table

```{r visualization-table}

	# create the plot
	subjectProfileSummaryPlot(
		data = subset(summaryTableDf, !isTotal & 
			PARCAT1 == "Ivacaftor" & grepl("Ctrough", PARAM)
		),
		xVar = "AVISIT",
		colorVar = "TRTP",
		labelVars = labelVars,
		useLinetype = TRUE,
		tableText = "statN"
	)

```

## By facets

```{r visualization-facets, out.width = "100%", fig.height = 15, fig.width = 15}

	# create the plot
	subjectProfileSummaryPlot(
		data = subset(summaryTableDf, !isTotal),
		xVar = "AVISIT",
		colorVar = "TRTP",
		labelVars = labelVars,
		facetVar = c("PARCAT1", "PARAM"),
		useLinetype = TRUE
	)

```

# Appendix

## Session information

```{r includeSessionInfo, echo = FALSE}

	pander(sessionInfo())

```
